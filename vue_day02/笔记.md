## 计算属性 监听属性
使用：逻辑复杂，模板难以维护
计算属性是基于依赖进行缓存的
computed：注重结果
    1.逻辑计算，防止模板过重
    2.监听，依赖修改 get方法必须return
watch: 监听 观察，注重过程 不用return
methods:
    1.点击事件处理函数，return 不是必须的   
    2.函数表达式的逻辑处理，没有缓存
## fetch&axios
```js
fetch请求默认不带cookie,需要设置fetch(url,{credentials:'include'})
fetch('./fetch.json').then(res=>res.json())
    .then(res=>{
        console.log(res);
    })
    //res.text() 字符串 res.json json对象
    fetch('./fetch.json',{method:'post',headers:{
        "Content-type":"application/json",
        "body":JSON.stringify({name:'张三',age:18})
    }}).then(res=>res.json())
    .then(res=>{
        console.log(res);
    })
    axios.get('./fetch.json').then(res=>{
        console.log(res);
    })
```
## 组件间通信
父传子：在父组件中通过给子组件绑定属性，子组件通过props接收传过来的数据
也可以通过ref:写在标签上，得到标签节点，写在组件上，得到组件对象
子传父：通过事件监听，父组件在子组件上绑定监听事件，子组件通过$emit触发事件
bus通信：发布订阅模式，组件使用$emit方法发布消息，另一个组件使用$on监听事件，获取消息 

## 动态组件
<component :is="组件名"></component>
## 过度
1.<transition></transition>
当有相同标签名元素切换时，需要通过key设置唯一值标记让vue区分他们，否则vue只会替换相同标签的
2.<transition-group></transition-group>
不同于transition，它会以正式元素呈现，默认为span,可以通过tag特性更换为其他元素,要设置唯一key值